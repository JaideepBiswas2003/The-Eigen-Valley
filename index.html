<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Eigen-Valley/title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; color: white; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; }
        
        /* Main UI Panel */
        #ui-panel {
            position: absolute; top: 20px; left: 20px; width: 300px;
            background: rgba(20, 20, 25, 0.95); padding: 20px;
            border-radius: 12px; border: 1px solid #333;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            max-height: 90vh; overflow-y: auto;
            z-index: 10;
        }
        h1 { font-size: 18px; margin: 0 0 15px 0; color: #4db8ff; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 12px; color: #aaa; margin-bottom: 5px; }
        input[type=range], select { width: 100%; accent-color: #4db8ff; }
        select { background: #333; color: white; border: 1px solid #555; padding: 5px; border-radius: 4px; width: 100%; }
        
        button {
            width: 100%; padding: 10px; background: #333; border: 1px solid #555;
            color: white; border-radius: 6px; cursor: pointer; margin-top: 10px;
            transition: all 0.2s; font-weight: 600;
        }
        button:hover { background: #4db8ff; border-color: #4db8ff; color: #000; }
        button.active { background: #ff0055; color: white; border-color: #ff0055; }
        button#info-btn { background: #444; border: 1px solid #666; margin-bottom: 15px; margin-top: 0; }
        button#info-btn:hover { background: #fff; color: #000; }

        /* Info Modal */
        #info-modal {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 100;
            justify-content: center; align-items: center;
        }
        .modal-content {
            background: #1a1a20; width: 600px; max-width: 90%; max-height: 90vh;
            border-radius: 12px; border: 1px solid #4db8ff;
            padding: 30px; overflow-y: auto;
            box-shadow: 0 0 30px rgba(77, 184, 255, 0.2);
            position: relative;
        }
        .close-btn {
            position: absolute; top: 15px; right: 20px;
            font-size: 24px; cursor: pointer; color: #aaa;
        }
        .close-btn:hover { color: white; }
        
        .modal-content h2 { color: #4db8ff; margin-top: 0; }
        .modal-content h3 { color: #ff0055; font-size: 16px; margin-top: 20px; margin-bottom: 5px; }
        .modal-content p { font-size: 14px; color: #ddd; line-height: 1.6; margin-bottom: 10px; }
        .modal-content ul { margin-left: 20px; color: #ccc; font-size: 14px; line-height: 1.5; }
        .modal-content li { margin-bottom: 8px; }
        .highlight { color: #4db8ff; font-weight: bold; }

        #stats { position: absolute; bottom: 20px; left: 20px; font-size: 10px; color: #555; }
    </style>
</head>
<body>
    <!-- Description Modal -->
    <div id="info-modal">
        <div class="modal-content">
            <span class="close-btn" id="close-modal">&times;</span>
            <h2>Project Guide: The Linear Algebra Landscape</h2>
            
            <p>This art project visualizes how abstract mathematical concepts create "natural" beauty. Instead of using traditional art tools, we used the language of vectors and matrices to sculpt this world.</p>

            <h3>Creative Approach</h3>
            <p>We treat the computer screen not as a canvas, but as a <strong>Vector Space</strong>. Every hill, tree, and raindrop is a vector being transformed by mathematical operations in real-time. It shows that "nature" in a computer is just a very complex system of linear equations.</p>

            <h3>Linear Algebra Concepts Used</h3>
            <ul>
                <li><strong>Vector Fields:</strong> The terrain isn't random. It is generated by a grid of "Gradient Vectors" that point in random directions. We use the <strong>Dot Product</strong> to blend these vectors together, creating smooth hills instead of jagged noise.</li>
                <li><strong>The Cross Product (Normals):</strong> To light the terrain, we need to know which way the ground faces. We calculate this by taking two tangent vectors on the surface and finding their Cross Product. This gives us the "Normal Vector" (perpendicular to the ground).</li>
                <li><strong>Eigen-Rain & Eigenvectors:</strong> In Linear Algebra, <strong>Eigenvectors</strong> represent the "natural flow" or stable axes of a transformation. Similarly, our rain particles find the "natural path" of the terrain. While technically using Gradient Descent, the rain conceptually mirrors how eigenvectors point to the principal direction of a system. The rain reveals the hidden structure (vector field) of the mountain.</li>
                <li><strong>Null Space (The River):</strong> The river represents a region where we force the terrain function to zero. Any input vector falling within the river's domain is mapped to the zero height, creating a "kernel" in our landscape.</li>
            </ul>

            <h3>How the Controls Work</h3>
            <ul>
                <li><strong>Grid Scale (Frequency):</strong> Adjusts the density of the vector field. Mathematically, this scales the input vector before it enters the noise function.</li>
                <li><strong>Mountain Amplitude:</strong> Performs <strong>Scalar Multiplication</strong> on the height vector, simply stretching the vertical values.</li>
                <li><strong>River Width:</strong> Expands the "Null Space" domain. Increasing this value widens the mathematical condition that forces the ground height to zero.</li>
                <li><strong>Octaves (Linear Combination):</strong> This adds complexity. We don't just run the noise function once; we run it multiple times at different frequencies (layers) and sum them up.</li>
                <li><strong>Regenerate World:</strong> This re-initializes the basis of our world. We discard the old grid and generate a fresh set of random <strong>Gradient Vectors</strong>. Since the entire world is just a function of these vectors, changing the basis creates a new universe.</li>
            </ul>
        </div>
    </div>

    <div id="ui-panel">
        <h1>Eigen-Valley Ecosystem</h1>
        <button id="info-btn">ðŸ“– Project Guide / How it Works</button>
        
        <div class="control-group">
            <label>Color Theme</label>
            <select id="theme-selector">
                <option value="earth">Earth (Height Map)</option>
                <option value="neon">Neon Night (Sci-Fi)</option>
                <option value="thermal">Thermal (Heat Map)</option>
                <option value="blueprint">Blueprint (Math Mode)</option>
            </select>
        </div>

        <div class="control-group">
            <label>Grid Scale (Frequency)</label>
            <input type="range" id="scale" min="10" max="100" value="35">
        </div>

        <div class="control-group">
            <label>Mountain Amplitude</label>
            <input type="range" id="amplitude" min="0" max="80" value="45">
        </div>
        
        <div class="control-group">
            <label>River Width</label>
            <input type="range" id="riverWidth" min="0" max="20" value="10">
        </div>

        <div class="control-group">
            <label>Octaves (Complexity)</label>
            <input type="range" id="octaves" min="1" max="5" step="1" value="3">
        </div>

        <button id="toggle-vectors">Show Surface Normals</button>
        <button id="toggle-rain">Start Eigen-Rain</button>
        <button id="toggle-wireframe">Toggle Wireframe</button>
        <button id="toggle-objects">Toggle Ecosystem</button>
        <button id="regenerate">Regenerate World</button>
    </div>
    
    <div id="canvas-container"></div>
    <div id="stats">Click & Drag to Rotate | Scroll to Zoom</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- UI Logic ---
        const modal = document.getElementById('info-modal');
        const btn = document.getElementById('info-btn');
        const close = document.getElementById('close-modal');

        btn.onclick = function() { modal.style.display = "flex"; }
        close.onclick = function() { modal.style.display = "none"; }
        window.onclick = function(event) {
            if (event.target == modal) { modal.style.display = "none"; }
        }

        // --- Math & Noise Implementation ---
        class PerlinNoise {
            constructor() {
                this.permutation = [];
                const p = [];
                for (let i = 0; i < 256; i++) p[i] = i;
                for (let i = 255; i > 0; i--) {
                    const r = Math.floor(Math.random() * (i + 1));
                    [p[i], p[r]] = [p[r], p[i]];
                }
                this.permutation = [...p, ...p];
                this.gradients = [
                    {x: 1, y: 1}, {x: -1, y: 1}, {x: 1, y: -1}, {x: -1, y: -1},
                    {x: 1, y: 0}, {x: -1, y: 0}, {x: 0, y: 1}, {x: 0, y: -1}
                ];
            }
            dot(g, x, y) { return g.x * x + g.y * y; }
            lerp(a, b, t) { return a + t * (b - a); }
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const p = this.permutation;
                const A = p[X] + Y, B = p[X+1] + Y;
                const g00 = this.gradients[p[A] % 8];
                const g10 = this.gradients[p[A+1] % 8];
                const g01 = this.gradients[p[B] % 8];
                const g11 = this.gradients[p[B+1] % 8];
                const d00 = this.dot(g00, x, y);
                const d10 = this.dot(g10, x-1, y);
                const d01 = this.dot(g01, x, y-1);
                const d11 = this.dot(g11, x-1, y-1);
                return this.lerp(this.lerp(d00, d10, u), this.lerp(d01, d11, u), v);
            }
        }

        //3D Scene Setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 60, 90);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true; 
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(20, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- Terrain Logic ---
        let terrainMesh, wireframeMesh, waterMesh, vectorArrows = [], objectGroup = new THREE.Group();
        let rainSystem; // Particle system for rain
        let rainParticlesData = []; // Store velocities/positions
        scene.add(objectGroup);
        
        let noiseGen = new PerlinNoise();

        // Color Palettes
        const THEMES = {
            earth: {
                bg: 0x88ccff, 
                colors: [
                    { h: -0.2, c: new THREE.Color(0x336644) }, 
                    { h: 0.05, c: new THREE.Color(0x448855) }, 
                    { h: 0.15, c: new THREE.Color(0xeecfa1) }, 
                    { h: 0.4, c: new THREE.Color(0x228800) },  
                    { h: 0.7, c: new THREE.Color(0x555555) },  
                    { h: 1.0, c: new THREE.Color(0xffffff) }   
                ],
                wire: 0xffffff, wireOp: 0.1,
                hasWater: true
            },
            neon: {
                bg: 0x050505,
                colors: [
                    { h: -1.0, c: new THREE.Color(0x110022) },
                    { h: 1.0, c: new THREE.Color(0xff00ff) }
                ],
                wire: 0x00ffff, wireOp: 0.5, solidColor: 0x111111,
                hasWater: false 
            },
            thermal: {
                bg: 0x000000,
                colors: [
                    { h: 0.0, c: new THREE.Color(0x0000ff) }, 
                    { h: 0.5, c: new THREE.Color(0xff0000) }, 
                    { h: 1.0, c: new THREE.Color(0xffff00) }  
                ],
                wire: 0xffffff, wireOp: 0.1,
                hasWater: false
            },
            blueprint: {
                bg: 0x1a2b3c,
                colors: [
                    { h: -1.0, c: new THREE.Color(0x0044aa) },
                    { h: 1.0, c: new THREE.Color(0x0088ff) }
                ],
                wire: 0xffffff, wireOp: 0.4,
                hasWater: false
            }
        };

        function getColorForHeight(h, themeName, slope = 0) {
            const theme = THEMES[themeName];
            if (themeName === 'neon') return new THREE.Color(0x222222); 

            // Slope- (Linear Algebra Gradient Magnitude)
            if (themeName === 'earth' && slope > 0.6 && h < 0.9) {
                const rockColor = new THREE.Color(0x555555);
                const t = Math.min(1.0, (slope - 0.6) * 3);
                
                let baseColor = new THREE.Color();
                for (let i = 0; i < theme.colors.length - 1; i++) {
                    if (h <= theme.colors[i+1].h) {
                        const ct = (h - theme.colors[i].h) / (theme.colors[i+1].h - theme.colors[i].h);
                        baseColor.lerpColors(theme.colors[i].c, theme.colors[i+1].c, ct);
                        break;
                    }
                }
                return baseColor.lerp(rockColor, t);
            }

            for (let i = 0; i < theme.colors.length - 1; i++) {
                if (h <= theme.colors[i+1].h) {
                    const t = (h - theme.colors[i].h) / (theme.colors[i+1].h - theme.colors[i].h);
                    return new THREE.Color().lerpColors(theme.colors[i].c, theme.colors[i+1].c, t);
                }
            }
            return theme.colors[theme.colors.length-1].c;
        }

        // Linear Algebra: Calculate Slope Magnitude
        function calculateGradientKernel(grid, x, y, width) {
            if (x <= 0 || x >= width - 1 || y <= 0 || y >= grid.length/width - 1) return 1.0;
            const left = grid[y * width + (x - 1)];
            const right = grid[y * width + (x + 1)];
            const up = grid[(y - 1) * width + x];
            const down = grid[(y + 1) * width + x];
            const dzdx = (right - left) / 2;
            const dzdy = (down - up) / 2;
            return Math.sqrt(dzdx*dzdx + dzdy*dzdy);
        }

        //Linear Algebra: Height Calculation Function
        function calculateHeight(x, z, scale, amp, riverWidth, octaves) {
            let noiseVal = 0;
            let frequency = scale;
            let amplitude = amp;

            for (let o = 0; o < octaves; o++) {
                noiseVal += noiseGen.noise(x * frequency + 100, z * frequency + 100) * amplitude;
                frequency *= 2;
                amplitude *= 0.5;
            }

            // Mountain Ridges (Absolute Value)
            const ridgeFreq = scale * 0.3;
            let ridgeNoise = noiseGen.noise(x * ridgeFreq + 123, z * ridgeFreq + 321);
            ridgeNoise = Math.abs(ridgeNoise);
            noiseVal += ridgeNoise * amp * 1.2;

            // Play Field Projection
            if (x > 10) {
                 noiseVal *= 0.2; 
                 noiseVal += 5;   
            }

            // River Function (Null Space)
            const riverPathX = Math.sin(z * 0.05) * 20 - 10;
            const distToRiver = Math.abs(x - riverPathX);
            if (riverWidth > 0) {
                const riverDepth = 15 * Math.exp(-(distToRiver * distToRiver) / (riverWidth * 2));
                noiseVal -= riverDepth;
            }
            return noiseVal;
        }

        function generateTerrain() {
            // Cleanup
            if (terrainMesh) {
                scene.remove(terrainMesh);
                scene.remove(wireframeMesh);
                terrainMesh.geometry.dispose();
                terrainMesh.material.dispose();
            }
            if (waterMesh) {
                scene.remove(waterMesh);
                waterMesh.geometry.dispose();
                waterMesh.material.dispose();
                waterMesh = null;
            }
            if (rainSystem) {
                scene.remove(rainSystem);
                rainSystem.geometry.dispose();
                rainSystem.material.dispose();
                rainSystem = null;
                rainParticlesData = [];
            }

            vectorArrows.forEach(a => scene.remove(a));
            vectorArrows = [];
            while(objectGroup.children.length > 0){ 
                objectGroup.remove(objectGroup.children[0]); 
            }

            const width = 120;
            const depth = 120;
            const segments = 120;
            
            const geometry = new THREE.PlaneGeometry(width, depth, segments, segments);
            const positions = geometry.attributes.position.array;
            
            // Parameters
            const scale = document.getElementById('scale').value / 1000;
            const amp = parseFloat(document.getElementById('amplitude').value);
            const riverWidth = parseFloat(document.getElementById('riverWidth').value);
            const octaves = parseInt(document.getElementById('octaves').value);
            const themeName = document.getElementById('theme-selector').value;
            const currentTheme = THEMES[themeName];

            scene.background = new THREE.Color(currentTheme.bg);

            // 1. Calculate Heights
            let minH = 0, maxH = 0;
            const heights = [];
            const heightGrid = new Float32Array((segments + 1) * (segments + 1));

            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1]; // Plane Y is World Z
                
                const noiseVal = calculateHeight(x, y, scale, amp, riverWidth, octaves);
                
                positions[i + 2] = noiseVal;
                
                // Store for Kernel processing
                const ix = (i / 3) % (segments + 1);
                const iy = Math.floor((i / 3) / (segments + 1));
                heightGrid[iy * (segments + 1) + ix] = noiseVal;

                heights.push(noiseVal);
                if (noiseVal < minH) minH = noiseVal;
                if (noiseVal > maxH) maxH = noiseVal;
            }

            geometry.computeVertexNormals();

            // 2. Vertex Colors
            const colors = [];
            const segW = segments + 1;
            
            for (let i = 0; i < heights.length; i++) {
                const ix = i % segW;
                const iy = Math.floor(i / segW);
                const slope = calculateGradientKernel(heightGrid, ix, iy, segW);
                const h = (heights[i] - minH) / (maxH - minH); 
                const c = getColorForHeight(h, themeName, slope);
                colors.push(c.r, c.g, c.b);
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            // Material
            const material = new THREE.MeshPhongMaterial({
                vertexColors: themeName !== 'neon', 
                color: themeName === 'neon' ? 0x111111 : 0xffffff,
                specular: 0x222222,
                shininess: 15,
                side: THREE.DoubleSide,
                flatShading: true
            });

            terrainMesh = new THREE.Mesh(geometry, material);
            terrainMesh.rotation.x = -Math.PI / 2;
            terrainMesh.receiveShadow = true;
            scene.add(terrainMesh);

            // Water
            if (currentTheme.hasWater) {
                const wGeo = new THREE.PlaneGeometry(width, depth, 60, 60);
                const wMat = new THREE.MeshPhongMaterial({
                    color: 0x0088cc, transparent: true, opacity: 0.6,
                    shininess: 100, specular: 0xffffff, side: THREE.DoubleSide
                });
                waterMesh = new THREE.Mesh(wGeo, wMat);
                waterMesh.rotation.x = -Math.PI / 2;
                waterMesh.position.y = -3;
                scene.add(waterMesh);
            }

            // Wireframe
            const wireGeo = new THREE.WireframeGeometry(geometry);
            const wireMat = new THREE.LineBasicMaterial({ 
                color: currentTheme.wire, transparent: true, opacity: currentTheme.wireOp 
            });
            wireframeMesh = new THREE.LineSegments(wireGeo, wireMat);
            wireframeMesh.rotation.x = -Math.PI / 2;
            wireframeMesh.visible = showWireframe || themeName === 'neon' || themeName === 'blueprint';
            if(themeName === 'neon' || themeName === 'blueprint') {
                document.getElementById('toggle-wireframe').classList.add('active');
                showWireframe = true;
            }
            scene.add(wireframeMesh);

            // 3. Objects (Trees, Rocks, Houses)
            if (showObjects) {
                const treeGeo = new THREE.ConeGeometry(0.8, 3, 5);
                const treeMat = new THREE.MeshLambertMaterial({ color: 0x228822 });
                const rockGeo = new THREE.DodecahedronGeometry(0.5);
                const rockMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const bigTreeGeo = new THREE.ConeGeometry(1.5, 6, 7);
                const bigTreeMat = new THREE.MeshLambertMaterial({ color: 0x1a5e1a });
                const houseBodyGeo = new THREE.BoxGeometry(3, 2.5, 3);
                const houseRoofGeo = new THREE.ConeGeometry(2.2, 1.5, 4);
                const houseBodyMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const houseRoofMat = new THREE.MeshLambertMaterial({ color: 0xA52A2A });

                for(let iy = 1; iy < segW - 1; iy += 2) {
                    for(let ix = 1; ix < segW - 1; ix += 2) {
                        const slope = calculateGradientKernel(heightGrid, ix, iy, segW);
                        const h = heightGrid[iy * segW + ix];
                        const posX = (ix / segments) * width - (width/2);
                        const posY = (iy / segments) * depth - (depth/2);
                        const rand = Math.random();

                        if (slope < 0.8 && h > -2 && h < 15 && rand > 0.96) {
                            const tree = new THREE.Mesh(treeGeo, treeMat);
                            tree.position.set(posX, h + 1.5, -posY);
                            tree.scale.setScalar(0.8 + Math.random() * 0.5);
                            tree.castShadow = true;
                            objectGroup.add(tree);
                        }
                        if (slope > 0.3 && slope < 1.2 && h > 5 && h < 25 && rand > 0.99) {
                            const bigTree = new THREE.Mesh(bigTreeGeo, bigTreeMat);
                            bigTree.position.set(posX, h + 3, -posY);
                            bigTree.scale.setScalar(0.9 + Math.random() * 0.4);
                            bigTree.castShadow = true;
                            objectGroup.add(bigTree);
                        }
                        if (slope < 0.4 && h > -1 && h < 5 && rand > 0.993) {
                            const houseGroup = new THREE.Group();
                            const body = new THREE.Mesh(houseBodyGeo, houseBodyMat);
                            body.position.y = 1.25; body.castShadow = true;
                            const roof = new THREE.Mesh(houseRoofGeo, houseRoofMat);
                            roof.position.y = 3.25; roof.rotation.y = Math.PI / 4; roof.castShadow = true;
                            houseGroup.add(body); houseGroup.add(roof);
                            houseGroup.position.set(posX, h, -posY);
                            houseGroup.rotation.y = Math.random() * Math.PI * 2;
                            objectGroup.add(houseGroup);
                        }
                        if (slope > 0.5 && h > -5 && h < 2 && rand > 0.98) {
                            const rock = new THREE.Mesh(rockGeo, rockMat);
                            rock.position.set(posX, h + 0.5, -posY);
                            rock.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
                            rock.castShadow = true;
                            objectGroup.add(rock);
                        }
                    }
                }
            }

            // 4. Generate Surface Normal Vectors
            if (showVectors) {
                for(let x = -width/2; x < width/2; x += 6) {
                    for(let z = -depth/2; z < depth/2; z += 6) {
                        const y = calculateHeight(x, z, scale, amp, riverWidth, octaves);
                        const delta = 0.5;
                        const yX = calculateHeight(x + delta, z, scale, amp, riverWidth, octaves);
                        const yZ = calculateHeight(x, z + delta, scale, amp, riverWidth, octaves);
                        
                        const tx = new THREE.Vector3(delta, yX - y, 0);
                        const tz = new THREE.Vector3(0, yZ - y, delta);
                        const normal = new THREE.Vector3().crossVectors(tz, tx).normalize();
                        
                        const origin = new THREE.Vector3(x, y + 2, z); 
                        const arrowHelper = new THREE.ArrowHelper(normal, origin, 5, 0xff0055);
                        vectorArrows.push(arrowHelper);
                        scene.add(arrowHelper);
                    }
                }
            }
            
            // 5. Initialize Eigen-Rain if active
            if (showRain) {
                initRain(width, depth);
            }
        }

        // Eigen-Rain (Gradient Descent Particle System) 
        function initRain(width, depth) {
            const particleCount = 2000;
            const geom = new THREE.BufferGeometry();
            const posArray = new Float32Array(particleCount * 5);
            
            for(let i=0; i<particleCount; i++) {
                // Spawn high above
                posArray[i*3] = (Math.random() - 0.5) * width;
                posArray[i*3+1] = 60 + Math.random() * 40;
                posArray[i*3+2] = (Math.random() - 0.5) * depth;
                
                // Init data for logic
                rainParticlesData.push({
                    x: posArray[i*3],
                    z: posArray[i*3+2],
                    active: true
                });
            }
            geom.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const mat = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.8, transparent: true, opacity: 0.8 });
            rainSystem = new THREE.Points(geom, mat);
            scene.add(rainSystem);
        }

        function updateRain() {
            if (!rainSystem) return;
            
            // Get current params for calculation
            const scale = document.getElementById('scale').value / 1000;
            const amp = parseFloat(document.getElementById('amplitude').value);
            const riverWidth = parseFloat(document.getElementById('riverWidth').value);
            const octaves = parseInt(document.getElementById('octaves').value);
            
            const positions = rainSystem.geometry.attributes.position.array;
            const width = 120; // assumed from world gen
            const depth = 120;
            
            for (let i = 0; i < rainParticlesData.length; i++) {
                let p = rainParticlesData[i];
                
                // Get terrain height at current X,Z
                let h = calculateHeight(p.x, p.z, scale, amp, riverWidth, octaves);
                
                // Check if particle is "In the sky" or "On the ground"
                let currentY = positions[i*3+1];
                
                if (currentY > h + 1) {
                    // Falling (Gravity)
                    currentY -= 0.8;
                } else {
                    // On Surface: Gradient Descent!
                    // Calculate Gradient (Slope) at this point
                    const delta = 0.5;
                    const hX = calculateHeight(p.x + delta, p.z, scale, amp, riverWidth, octaves);
                    const hZ = calculateHeight(p.x, p.z + delta, scale, amp, riverWidth, octaves);
                    
                    // Gradient Vector (Partial Derivatives)
                    const dHdX = (hX - h) / delta;
                    const dHdZ = (hZ - h) / delta;
                    
                    // Move opposite to gradient (Downhill)
                    // New Position = Old Pos - LearningRate * Gradient
                    const alpha = 0.4; // Learning rate (speed)
                    p.x -= alpha * dHdX;
                    p.z -= alpha * dHdZ;
                    
                    // Update Y to stick to surface
                    h = calculateHeight(p.x, p.z, scale, amp, riverWidth, octaves);
                    currentY = h + 0.5;
                    
                    // Boundary / Pool check
                    // If in river (low height) or OOB, respawn
                    if (h < -2 || Math.abs(p.x) > width/2 || Math.abs(p.z) > depth/2) {
                         p.x = (Math.random() - 0.5) * width;
                         p.z = (Math.random() - 0.5) * depth;
                         currentY = 60 + Math.random() * 40;
                    }
                }
                
                positions[i*3] = p.x;
                positions[i*3+1] = currentY;
                positions[i*3+2] = p.z;
            }
            rainSystem.geometry.attributes.position.needsUpdate = true;
        }

        //Interaction
        let showVectors = false;
        let showWireframe = false;
        let showObjects = true;
        let showRain = false;

        document.getElementById('scale').addEventListener('input', generateTerrain);
        document.getElementById('amplitude').addEventListener('input', generateTerrain);
        document.getElementById('riverWidth').addEventListener('input', generateTerrain);
        document.getElementById('octaves').addEventListener('input', generateTerrain);
        document.getElementById('theme-selector').addEventListener('change', generateTerrain);
        
        document.getElementById('regenerate').addEventListener('click', () => {
            noiseGen = new PerlinNoise();
            generateTerrain();
        });

        document.getElementById('toggle-vectors').addEventListener('click', (e) => {
            showVectors = !showVectors;
            e.target.classList.toggle('active');
            generateTerrain();
        });
        
        document.getElementById('toggle-rain').addEventListener('click', (e) => {
            showRain = !showRain;
            e.target.classList.toggle('active');
            generateTerrain();
        });

        document.getElementById('toggle-wireframe').addEventListener('click', (e) => {
            showWireframe = !showWireframe;
            e.target.classList.toggle('active');
            if(wireframeMesh) wireframeMesh.visible = showWireframe;
        });

        document.getElementById('toggle-objects').addEventListener('click', (e) => {
            showObjects = !showObjects;
            e.target.classList.toggle('active');
            generateTerrain();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            time += 0.005;
            const sunX = Math.cos(time) * 100;
            const sunZ = Math.sin(time) * 100;
            dirLight.position.set(sunX, 100, sunZ);
            if (waterMesh) {
                const positions = waterMesh.geometry.attributes.position.array;
                for(let i=0; i < positions.length; i+=3) {
                    const x = positions[i];
                    const y = positions[i+1]; 
                    positions[i+2] = Math.sin(x * 0.1 + time * 2) * 0.3 + Math.cos(y * 0.1 + time) * 0.3;}
                waterMesh.geometry.attributes.position.needsUpdate = true;}
            if (showRain) {
                updateRain();}
            renderer.render(scene, camera);}
        generateTerrain();
        animate();
    </script>
</body>
</html>
